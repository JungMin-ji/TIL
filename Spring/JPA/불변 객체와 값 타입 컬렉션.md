## 값 타입 공유 참조

임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 부작용(side effect)발생할 수 있음

예를 들어, 회원1과 회원2가 있다고 가정할 때, 회원1의 주소만 바꾸려고 한다.

(Member에서 Address를 임베디드 값 타입으로 사용함)

```jsx
Address address = new Address("city", "street1", "1000");
Member mem1 = new Memeber("mem1");
Member mem2 = new Memeber("mem1");

em.persist(mem1);
em.persist(mem2);

mem1.getHomeAddress().setCity("newCity");
```

하지만, 이 경우 회원2의 주소도 바뀌게 된다. 

![_2021-07-19_17-25-24](https://user-images.githubusercontent.com/52596617/126353024-30ed06bb-a32e-4c56-b0c1-0c8eec96538e.png)

💡 다음과 같이 한 임베디드 값 타입을 공유하는 구조를 가지는 것을 명심!

⇒ 값을 복사해서 사용해라! 그리고 불변 객체로 만들어 부작용을 차단해라! 

## 불변 객체

객체 타입을 수정할 수 없게 만들어 부작용을 원천적으로 차단한다.

⭐ 값 타입은 불변 객체로 설계해야 한다!!! ⭐

- 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 됨
- Integer, String은 자바가 제공하는 대표적인 불변 객체이다.

## 값 타입 비교

인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 함!

```jsx
Address a = new Address("city");
Address b = new Address("city");
```

- 동일성 비교 : == 사용 → 인스턴스의 참조 값 비교
- 동등성 비교 : equals() 사용 → 인스턴스의 값 비교

> 값 타입의 equals() 메서드를 재정의하여 비교한다! (주로 모든 필드 사용)

## 값 타입 컬렉션

Member에서 Address를 List로 관리하고 싶을 때 

→ DB로 표현하면 MEMBER 테이블과  ADDRESS 테이블이 일대다 관계!

### 사용법

```jsx
@ElementCollection
@CollectionTable(name="테이블명", 
joinColumns = @JoinColumn(name="MEMBER_ID")
private List<Address> addressHistory = new ArrayList<>();
```

### 특징

- **값 타입 저장** : 값 타입의 생명 주기는 해당 엔티티의 의존적이다! → member만 persist(저장)해도 address 자동으로 저장됨

    - 값 타입 컬렉션은 연속성 전이(Casecade) + 고아 객체 제거 기능을 필수로 가짐 

- **값 타입 조회** : 지연 로딩 전략 사용
- **값 타입 수정** : setter 사용x → 삭제하고, 완전히 new 생성해서 갈아끼워야 함

### 값 타입 컬렉션의 제약사항

- 엔티티와 달리 값 타입은 식별자 개념이 없기 때문에 변경 시 추적이 어렵다.
- 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.

    → 여기서 변경되지 않는 값들도 삭제하고 다시 컬렉션에 저장한다! 

- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 함 → null x, 중복 저장x

> 실무에서는 상황에 따라 일대다 관계를 사용하여 값 타입 컬렉션을 대신한다.

💡 값 타입 컬렉션은 굉장히! 단순할 때만 사용하고, 아닌 경우 엔티티로 사용한다!
