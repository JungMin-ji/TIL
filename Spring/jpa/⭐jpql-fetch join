## ⭐ 페치 조인⭐

SQL에서는 없지만, JPQL에서 성능 최적화를 위해 사용하는 기능이다.

연관된 엔티티나 컬렉션을 SQL 한 방에 한꺼번에 조회하는 기능이다.

- 글로벌 로딩 전략(FetchType.LAZY) 보다 우선으로 실행

예) SQL 한 방에 회원을 조회하면서 연관된 팀 조회

`JPQL`

```sql
select m 
from Member m join fetch m.team
```

라고 날리면, 

```sql
select m.*, t.* 
from Member m inner join Team t
on m.team_id=t.id
```

다음과 같은 sql처럼 동작한다.

**join fetch 뒤에 오는 엔티티가 딸려 같이 조회되는 것임!**

### ❗ 일대다 관계에서 컬렉션을 페치 조인하는 경우

```sql
select t
from Team t join fetch t.members
```

**데이터가 뻥튀기될 수 있다!**

*예를 들어*  teamA인 member1, teamA인 member2, teamB인 member3있다고 가정하자. 

team과 members를 페치 조인하면 teamA는 member1, member2와 페치 조인하게 된다. + teamB까지 해서 총 3개의 레코드가 있는 것과 같다. 그래서 count(t) 는 3개가 된다. 

팀의 개수는 총 2개이지만, 페치 조인하게 되면, 팀의 개수는 총 3개가 된다. 

이렇게 컬렉션을 페치 조인하는 경우 데이터가 뻥튀기될 수 있다는 것을 명심하자! 

## 페치 조인 + DISTINCT

기능

1. SQL에 distinct 를 넣어 중복된 결과 제거
2. 애플리케이션에서 엔티티 중복 제거 

```sql
select distinct t
from Team t join fetch t.members
```

위 예제에서 teamA가 두 번 있다고 해서 distinct를 사용해도 teamA의 중복이 제거되지 않는다. 왜냐하면, member1과 member2가 다른 데이터기 때문이다. 여기서 제거되는 값은 **페치 조인을 하고 나서** **모든 레코드의 속성 값을 비교했을 때 일치되는 경우만 해당된다**. 

## 페치 조인과 조인의 차이

- 일반 조인 → 결과 반환 시 연관관계 고려 X
- 페치 조인 → 객체 그래프를 SQL 한 번에 조회한다고 보면 됨

## 페치 조인과 즉시 로딩

- 즉시 로딩 : N+1 문제 발생
- 페치 조인 : 프록시가 아닌 실제 엔티티를 조회하며 연관관계 객체 까지 퀴리 한 방에 가져오기 때문에 N+1문제 발생 X

## 페치 조인의 한계

- 페치 조인 대상에는 별칭 X
- 둘 이상의 컬렉션은 페치 조인 불가능
- 컬렉션 페치 조인 시 페이징 API 사용 X (단, 일대일, 다대일 같은 단일 값 연관 필드는 페이징 사용 가능하나, 매우 위험한 일!)

> 💡 글로벌 로딩 전략은 모두 지연 로딩으로 설정, 최적화 필요한 곳은 페지 적용 설정함@!!!

❗ 여러 테이블 조인하고 나온 결과에서 변형시켜 전혀 다른 결과를 내야 한다면, 페치 조인보다는 일반 조인 + 필요한 필드만 뽑아내서 DTO 사용이 효과적이다.
